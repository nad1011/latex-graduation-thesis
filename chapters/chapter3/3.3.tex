\section{Mẫu giao tiếp bất đồng bộ (một đối một)}
Giao tiếp bất đồng bộ một đối một là một phương pháp quan trọng trong kiến trúc vi dịch vụ, tạo nên sự tách rời giữa các dịch vụ và cải thiện khả năng mở rộng của hệ thống. Không giống như giao tiếp đồng bộ, trong giao tiếp bất đồng bộ một đối một, vi dịch vụ gửi tin nhắn không cần đợi phản hồi tức thì từ vi dịch vụ nhận. Phần này sẽ tìm hiểu chi tiết về các mẫu giao tiếp bất đồng bộ một đối một phổ biến, cùng với các công nghệ triển khai và các trường hợp sử dụng thực tế.

\subsection{Cơ chế hoạt động}
Giao tiếp bất đồng bộ một đối một hoạt động theo mô hình khác biệt so với giao tiếp đồng bộ, với đặc điểm chính là sự phi chặn (non-blocking) trong quá trình truyền tải tin nhắn. Thay vì chờ đợi phản hồi, sender tiếp tục thực hiện các hoạt động khác sau khi gửi tin nhắn, và receiver xử lý tin nhắn khi có khả năng. Cơ chế này thường được triển khai thông qua một thành phần trung gian, có thể là message broker hoặc queue, đóng vai trò lưu trữ tạm thời tin nhắn khi receiver chưa sẵn sàng nhận \cite{hohpe2004}.

Quá trình giao tiếp bất đồng bộ một đối một thường tuân theo các bước sau: sender chuẩn bị tin nhắn với đầy đủ thông tin cần thiết; sender gửi tin nhắn đến hệ thống trung gian (message broker hoặc queue) mà không đợi phản hồi; sender tiếp tục xử lý các tác vụ khác; tin nhắn được lưu trữ trong hệ thống trung gian cho đến khi receiver sẵn sàng; receiver lấy tin nhắn từ hệ thống trung gian khi có thể; receiver xử lý tin nhắn theo logic nghiệp vụ của nó; tùy thuộc vào mẫu cụ thể, receiver có thể hoặc không gửi phản hồi.

Một khía cạnh quan trọng của giao tiếp bất đồng bộ là cơ chế delivery guarantee. Có ba mức độ đảm bảo phổ biến: at-most-once (tin nhắn có thể bị mất nhưng không bao giờ được gửi hơn một lần), at-least-once (tin nhắn được đảm bảo gửi ít nhất một lần, nhưng có thể trùng lặp), và exactly-once (tin nhắn được đảm bảo gửi chính xác một lần). Mức độ đảm bảo nào được sử dụng phụ thuộc vào yêu cầu nghiệp vụ và khả năng của hệ thống messaging \cite{newman2015}.

Một cơ chế khác cần xem xét là message ordering. Trong một số trường hợp, thứ tự xử lý tin nhắn là quan trọng (ví dụ, tin nhắn cập nhật giá trị phải được xử lý sau tin nhắn tạo giá trị). Một số message broker đảm bảo thứ tự tin nhắn trong một partition hoặc queue cụ thể, trong khi những broker khác có thể không cung cấp đảm bảo này.

\subsection{Mẫu One-way Notifications}
Mẫu One-way Notifications là hình thức đơn giản nhất của giao tiếp bất đồng bộ một đối một. Trong mẫu này, một vi dịch vụ gửi tin nhắn tới một vi dịch vụ khác mà không mong đợi phản hồi. Đây là mẫu hoàn toàn "fire-and-forget", trong đó sender không quan tâm đến việc tin nhắn được xử lý như thế nào hoặc khi nào \cite{hohpe2004}.

Mẫu One-way Notifications đặc biệt hữu ích cho các thông báo sự kiện không yêu cầu phản hồi, chẳng hạn như cập nhật trạng thái, ghi nhật ký, hoặc theo dõi hoạt động. Chẳng hạn, khi một đơn hàng được cập nhật, dịch vụ đơn hàng có thể gửi thông báo cho dịch vụ thông báo mà không cần đợi phản hồi.

Triển khai mẫu One-way Notifications thường đơn giản hơn so với các mẫu bất đồng bộ khác, vì không cần cơ chế tương quan giữa yêu cầu và phản hồi. Sender chỉ cần đặt tin nhắn vào hàng đợi hoặc chủ đề, và receiver xử lý nó khi sẵn sàng.

Các công nghệ phổ biến cho One-way Notifications bao gồm RabbitMQ, Apache Kafka, Amazon SQS, và Google Cloud Pub/Sub. Ví dụ, trong RabbitMQ, sender có thể xuất bản tin nhắn tới một exchange, và RabbitMQ định tuyến tin nhắn tới hàng đợi phù hợp dựa trên routing key. Receiver đăng ký hàng đợi và xử lý tin nhắn khi chúng đến. Apache Kafka hoạt động tương tự, với sender xuất bản tin nhắn tới chủ đề, và receiver đăng ký chủ đề để nhận tin nhắn.

Theo Newman \cite{newman2015}, một khía cạnh quan trọng của One-way Notifications là xử lý lỗi. Vì sender không đợi phản hồi, việc xử lý lỗi phải được xử lý khác với giao tiếp đồng bộ. Các tiếp cận phổ biến bao gồm sử dụng Dead Letter Queues (DLQ) để lưu trữ tin nhắn không thể xử lý, các cơ chế thử lại để thử lại tin nhắn lỗi, và các cơ chế logging và monitoring để phát hiện và giải quyết vấn đề.

Richardson \cite{richardson2019} đề xuất một số best practices khi triển khai One-way Notifications, bao gồm sử dụng message versioning để hỗ trợ backward và forward compatibility, triển khai idempotent message handling để tránh xử lý lặp lại tin nhắn, và sử dụng message acknowledgements để đảm bảo tin nhắn được xử lý thành công.

\subsection{Mẫu Message Queue}
Message Queue là một mẫu cơ bản trong giao tiếp bất đồng bộ, trong đó các tin nhắn được gửi tới một hàng đợi trung gian, nơi chúng được lưu trữ cho đến khi được xử lý bởi consumer. Mẫu này hỗ trợ cả One-way Notifications và các mẫu bất đồng bộ khác, và cung cấp nhiều lợi ích như tách rời, buffering, và reliable delivery \cite{hohpe2004}.

Trong kiến trúc Message Queue, thường có ba thành phần chính: Producer đặt tin nhắn vào hàng đợi; Queue lưu trữ tin nhắn cho đến khi chúng được xử lý; và Consumer lấy tin nhắn từ hàng đợi và xử lý chúng. Một tính năng quan trọng của Message Queue là nó cho phép asynchronous consumption, có nghĩa là tin nhắn không cần được xử lý ngay lập tức khi chúng đến. Điều này giúp xử lý các peak load và bảo vệ các dịch vụ khi chúng đang quá tải.

Các công nghệ Message Queue phổ biến bao gồm RabbitMQ, Apache ActiveMQ, Amazon SQS, và Microsoft Azure Service Bus. Mỗi công nghệ có những đặc điểm và ưu điểm riêng. Ví dụ, RabbitMQ hỗ trợ nhiều mẫu messaging như work queues, publish/subscribe, routing, và topics. Nó cũng cung cấp các tính năng như message acknowledgement, durability, và fair dispatch. Amazon SQS là một dịch vụ hàng đợi tin nhắn được quản lý, cung cấp các tính năng như at-least-once delivery, message retention, và visibility timeout.

Một khía cạnh quan trọng của Mecassage Queue là khả năng mở rộng. Có hai cách chính để mở rộng hệ thống Message Queue: horizontal scaling (thêm nhiều consumer để xử lý nhiều tin nhắn hơn song song) và partitioning (chia hàng đợi thành nhiều partition, mỗi partition được xử lý bởi một consumer).

Hohpe và Woolf \cite{hohpe2004} mô tả nhiều mẫu messaging chi tiết hơn liên quan đến Message Queue, bao gồm Competing Consumers (nhiều consumer cạnh tranh để xử lý tin nhắn từ một hàng đợi), Message Dispatcher (định tuyến tin nhắn tới consumer cụ thể dựa trên một số tiêu chí), và Priority Queue (tin nhắn ưu tiên cao được xử lý trước).

Trong kiến trúc vi dịch vụ, Message Queue thường được sử dụng để xử lý các tác vụ nặng hoặc tốn thời gian bất đồng bộ. Ví dụ, khi một người dùng đăng ký, dịch vụ đăng ký có thể đặt một tin nhắn vào hàng đợi để gửi email xác nhận, trong khi vẫn phản hồi ngay lập tức cho người dùng.

\subsection{Ưu điểm và Hạn chế của giao tiếp bất đồng bộ (một đối một)}
Giao tiếp bất đồng bộ một đối một có nhiều ưu điểm và hạn chế đáng chú ý so với giao tiếp đồng bộ, hiểu rõ những điểm mạnh và điểm yếu này là chìa khóa để lựa chọn mẫu giao tiếp phù hợp.

Về ưu điểm, tách rời là lợi ích lớn nhất của giao tiếp bất đồng bộ. Các dịch vụ giao tiếp không cần biết về nhau hoặc thậm chí hoạt động đồng thời. Sender có thể gửi tin nhắn ngay cả khi receiver đang ngoại tuyến, và receiver có thể xử lý tin nhắn khi sẵn sàng. Điều này làm giảm đáng kể phụ thuộc giữa các dịch vụ. Ưu điểm thứ hai là khả năng phục hồi cải thiện. Giao tiếp bất đồng bộ có thể chịu được lỗi dịch vụ tạm thời, vì tin nhắn có thể lưu trữ trong hàng đợi cho đến khi receiver khả dụng. Điều này giúp hệ thống duy trì hoạt động ngay cả khi một số thành phần gặp sự cố. Thứ ba, giao tiếp bất đồng bộ cung cấp khả năng mở rộng tốt hơn, cho phép mở rộng linh hoạt hơn bằng cách thêm nhiều receiver để xử lý nhiều tin nhắn hơn song song, mà không cần thay đổi sender. Ngoài ra, bất đồng bộ giúp cải thiện khả năng phản hồi và hiệu suất, vì sender không cần đợi receiver xử lý yêu cầu, do đó giảm thời gian chờ và cải thiện trải nghiệm người dùng. Giao tiếp bất đồng bộ cũng cung cấp buffering và smoothing, hàng đợi tin nhắn có thể hấp thụ đỉnh tải và bảo vệ dịch vụ khỏi quá tải. Cuối cùng, giao tiếp bất đồng bộ cải thiện sử dụng tài nguyên, vì dịch vụ không chặn tài nguyên chờ phản hồi, cho phép sử dụng tài nguyên hiệu quả hơn.

Tuy nhiên, giao tiếp bất đồng bộ cũng có những hạn chế đáng kể. Đầu tiên là độ phức tạp gia tăng. Giao tiếp bất đồng bộ thường đòi hỏi cơ sở hạ tầng bổ sung (như message broker) và logic phức tạp hơn để xử lý tin nhắn, quản lý lỗi, và đảm bảo tin cậy, làm tăng độ phức tạp của hệ thống. Hạn chế thứ hai là tính nhất quán yếu hơn. Bất đồng bộ thường dẫn đến eventual consistency thay vì strong consistency, nghĩa là có độ trễ trước khi tất cả các dịch vụ phản ánh cùng một trạng thái. Điều này có thể là một thách thức đối với các hệ thống yêu cầu tính nhất quán cao. Thứ ba, debugging và tracing có thể phức tạp hơn trong giao tiếp bất đồng bộ, vì luồng tin nhắn không trực quan như yêu cầu-phản hồi đồng bộ. Theo dõi tin nhắn qua nhiều dịch vụ và hàng đợi có thể là một thách thức. Giao tiếp bất đồng bộ cũng gặp phải vấn đề về độ tin cậy và mất tin nhắn. Mặc dù nhiều message broker cung cấp các cơ chế đảm bảo độ tin cậy như message acknowledgement và persistent messaging, nhưng vẫn có nguy cơ mất tin nhắn hoặc trùng lặp tin nhắn. Cuối cùng, độ trễ đầu cuối cao hơn. Mặc dù giao tiếp bất đồng bộ cải thiện độ phản hồi của sender, độ trễ đầu cuối (từ khi gửi tin nhắn đến khi hoàn thành xử lý) thường cao hơn so với giao tiếp đồng bộ.

Để giảm thiểu những hạn chế này, nhiều kỹ thuật và mẫu thiết kế đã được phát triển, Ví dụ, để giải quyết vấn đề tính nhất quán yếu, mẫu thiết kế như Saga và Event Sourcing có thể được sử dụng để quản lý giao dịch phân tán và duy trì tính nhất quán trong hệ thống bất đồng bộ. Để cải thiện khả năng debugging và tracing, các công cụ như Zipkin và Jaeger có thể được sử dụng để theo dõi tin nhắn qua hệ thống phân tán. Và để cải thiện độ tin cậy, các message broker cung cấp các tính năng như message acknowledgement, dead letter queues, và persistent messaging.

\subsection{Use cases phù hợp cho giao tiếp bất đồng bộ (một đối một)}
Giao tiếp bất đồng bộ một đối một đặc biệt phù hợp cho một số trường hợp sử dụng cụ thể trong kiến trúc vi dịch vụ. Hiểu rõ những trường hợp này giúp kiến trúc sư và nhà phát triển đưa ra quyết định đúng đắn về việc khi nào nên sử dụng giao tiếp bất đồng bộ.

Trường hợp sử dụng đầu tiên và quan trọng nhất là xử lý background. Các tác vụ tốn thời gian hoặc tài nguyên không cần phản hồi ngay lập tức là ứng viên lý tưởng cho giao tiếp bất đồng bộ. Ví dụ, khi người dùng tải lên video, việc xử lý video (như chuyển đổi định dạng, tạo thumbnail) có thể được thực hiện bất đồng bộ trong background, trong khi người dùng nhận được phản hồi ngay lập tức rằng quá trình tải lên đã hoàn tất.

Trường hợp thứ hai là xử lý số lượng lớn. Khi một dịch vụ cần xử lý số lượng lớn yêu cầu, giao tiếp bất đồng bộ cho phép điều tiết tải thông qua buffering và sử dụng nhiều receiver để xử lý song song. Ví dụ, hệ thống xử lý log hoặc các ứng dụng phân tích dữ liệu lớn có thể sử dụng giao tiếp bất đồng bộ để thu thập và xử lý dữ liệu từ nhiều nguồn.

Trường hợp thứ ba là cải thiện phản hồi người dùng. Trong các tình huống mà phản hồi ngay lập tức cho người dùng là quan trọng, nhưng xử lý hoàn chỉnh có thể hoàn thành sau, giao tiếp bất đồng bộ cho phép hệ thống phản hồi ngay lập tức trong khi tiếp tục xử lý trong background. Ví dụ, khi đặt đơn hàng trực tuyến, hệ thống có thể xác nhận đơn hàng ngay lập tức và xử lý thanh toán, gửi email xác nhận, và cập nhật kho bất đồng bộ.

Trường hợp thứ tư là long-running processes. Các quy trình nghiệp vụ kéo dài, liên quan đến nhiều bước hoặc tương tác với nhiều dịch vụ hay hệ thống bên ngoài, phù hợp với giao tiếp bất đồng bộ. Ví dụ, quy trình onboarding khách hàng có thể yêu cầu nhiều kiểm tra (như xác minh danh tính, kiểm tra tín dụng) có thể mất nhiều thời gian, trong khi khách hàng không nên phải đợi quá trình này hoàn tất.

Trường hợp cuối cùng là integration với hệ thống bên ngoài. Khi giao tiếp với hệ thống bên ngoài không trong quyền kiểm soát của bạn, giao tiếp bất đồng bộ cung cấp sự cách ly và khả năng phục hồi. Nếu hệ thống bên ngoài chậm hoặc không khả dụng, hệ thống của bạn có thể tiếp tục hoạt động và xử lý yêu cầu khi hệ thống bên ngoài trở lại.

Bên cạnh đó, các hệ thống cần khả năng chịu lỗi cao và lỏng lẻo về tính nhất quán dữ liệu thường phù hợp với giao tiếp bất đồng bộ \cite{fowler2002}. Tiếp cận bất đồng bộ cho phép hệ thống tiếp tục hoạt động ngay cả khi một số thành phần gặp sự cố, mặc dù có thể dẫn đến tính nhất quán yếu hơn (eventual consistency).

\subsection{Case studies}
Để hiểu rõ hơn về cách giao tiếp bất đồng bộ một đối một được triển khai và sử dụng trong thực tiễn, khóa luận luận sẽ phân tích một số trường hợp nghiên cứu từ các công ty nổi tiếng.

LinkedIn là một ví dụ nổi bật về việc sử dụng giao tiếp bất đồng bộ một đối một trong kiến trúc vi dịch vụ quy mô lớn. Họ đã phát triển và sử dụng Apache Kafka, một nền tảng streaming phân tán, để xử lý hàng nghìn tỉ tin nhắn mỗi ngày \cite{goodhope2012}. LinkedIn sử dụng Kafka cho nhiều mục đích, bao gồm activity tracking, xử lý sự kiện real-time, và đồng bộ hóa dữ liệu giữa các hệ thống khác nhau. Ví dụ, khi một người dùng thực hiện hành động như cập nhật profile hoặc kết nối với người dùng khác, hành động này được ghi lại như một sự kiện và được gửi tới Kafka. Các dịch vụ khác nhau, như dịch vụ đề xuất kết nối hoặc dịch vụ thông báo, sau đó xử lý sự kiện này để cập nhật dữ liệu và cung cấp chức năng của chúng.

PayPal cũng là một ví dụ đáng chú ý về việc sử dụng giao tiếp bất đồng bộ một đối một trong một hệ thống xử lý thanh toán cần độ tin cậy cao. PayPal đã chuyển đổi từ một kiến trúc nguyên khối sang vi dịch vụ, sử dụng Apache Kafka làm platform tin nhắn chính \cite{raman2016}. Trong kiến trúc này, các dịch vụ như xử lý thanh toán, phát hiện gian lận, và thông báo người dùng giao tiếp bất đồng bộ thông qua Kafka. Ví dụ, khi một giao dịch được khởi tạo, một sự kiện được gửi tới Kafka và được xử lý bởi nhiều dịch vụ khác nhau, bao gồm dịch vụ xác thực, dịch vụ phát hiện gian lận, và dịch vụ xử lý giao dịch. Mỗi dịch vụ thực hiện chức năng cụ thể của nó và có thể tạo ra các sự kiện khác, tạo thành một luồng xử lý transaction.

Uber cũng sử dụng giao tiếp bất đồng bộ một đối một rộng rãi trong kiến trúc vi dịch vụ của họ. Uber đã xây dựng một platform gọi là Cadence, một service orchestration engine cho phép viết workflow code như code đồng bộ, nhưng thực thi chúng bất đồng bộ và phân tán \cite{fateev2017}. Cadence được sử dụng cho nhiều use-case trong Uber, bao gồm matching riders với drivers, thanh toán, và onboarding drivers. Ví dụ, khi một yêu cầu chuyến đi được tạo, Cadence khởi tạo một workflow để tìm driver phù hợp, đặt lịch chuyến đi, xử lý thanh toán, và cập nhật trạng thái của rider và driver. Mỗi bước trong workflow này được thực hiện bất đồng bộ, cho phép quá trình tiếp tục ngay cả khi một số dịch vụ tạm thời không khả dụng.

Những trường hợp nghiên cứu này minh họa cách các công ty lớn triển khai giao tiếp bất đồng bộ một đối một để xây dựng hệ thống phân tán có khả năng mở rộng, linh hoạt, và đáng tin cậy. Chúng cũng cho thấy rằng giao tiếp bất đồng bộ đặc biệt hữu ích cho các hệ thống xử lý số lượng lớn giao dịch hoặc sự kiện, và cho các quy trình nghiệp vụ phức tạp liên quan đến nhiều service.