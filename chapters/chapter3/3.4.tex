\section{Asynchronous Communication Patterns (one-to-many)}
Giao tiếp bất đồng bộ one-to-many là mô hình quan trọng trong kiến trúc microservice, cho phép một dịch vụ gửi thông điệp đến nhiều dịch vụ nhận khác nhau cùng một lúc. Không giống như mô hình one-to-one, trong giao tiếp one-to-many, một thông điệp được phân phối đến nhiều người nhận mà không cần biết trước danh tính hoặc số lượng người nhận. Mô hình này đặc biệt hữu ích trong các hệ thống phân tán quy mô lớn, nơi cần thông báo nhiều thành phần về các sự kiện quan trọng \cite{newman2015}. Phần này sẽ tìm hiểu chi tiết về các mẫu giao tiếp bất đồng bộ one-to-many phổ biến, cùng với các công nghệ triển khai và các trường hợp sử dụng thực tế.
\subsection{Cơ chế hoạt động}
Giao tiếp bất đồng bộ one-to-many hoạt động theo nguyên tắc phân phối thông điệp từ một nguồn đến nhiều đích mà không yêu cầu sự tương tác trực tiếp giữa chúng. Thay vì thiết lập kết nối trực tiếp với từng người nhận, người gửi phát hành thông điệp đến một kênh trung gian, và thông điệp này được phân phối đến tất cả các dịch vụ đã đăng ký với kênh đó \cite{hohpe2004}.
Quá trình giao tiếp bất đồng bộ one-to-many thường tuân theo các bước sau: nhà xuất bản (publisher) chuẩn bị thông điệp; nhà xuất bản gửi thông điệp đến kênh hoặc topic trung gian; hệ thống trung gian nhận thông điệp và lưu trữ tạm thời; hệ thống trung gian xác định tất cả người đăng ký (subscribers) cho kênh hoặc topic đó; hệ thống trung gian phân phối thông điệp đến tất cả người đăng ký phù hợp; các người đăng ký nhận và xử lý thông điệp độc lập với nhau.
Một yếu tố quan trọng trong giao tiếp one-to-many là khả năng mở rộng động số lượng người nhận. Các dịch vụ mới có thể đăng ký nhận thông điệp mà không cần thay đổi logic của nhà xuất bản, tạo nên sự linh hoạt cao cho hệ thống. Đồng thời, nhiều hệ thống trung gian còn hỗ trợ các cơ chế lọc thông điệp, cho phép người đăng ký chỉ nhận những thông điệp phù hợp với tiêu chí cụ thể \cite{richardson2019}.
Cũng như trong giao tiếp one-to-one, các cơ chế đảm bảo độ tin cậy của thông điệp như at-most-once, at-least-once hoặc exactly-once đều có thể được áp dụng tùy theo yêu cầu của hệ thống. Tuy nhiên, do tính chất phân phối đến nhiều người nhận, việc đảm bảo thông điệp được nhận bởi tất cả người đăng ký có thể phức tạp hơn \cite{aksakalli2021}.
\subsection{Publish/Subscribe Pattern}
Publish/Subscribe (Pub/Sub) là mẫu giao tiếp không đồng bộ one-to-many phổ biến nhất trong kiến trúc microservice. Trong mô hình này, nhà xuất bản (publisher) không gửi thông điệp trực tiếp đến người nhận cụ thể, mà thay vào đó phát hành (publish) thông điệp đến một kênh (topic hoặc channel). Các dịch vụ quan tâm đến loại thông điệp này đăng ký (subscribe) vào kênh đó và nhận tất cả thông điệp được phát hành \cite{hohpe2004}.
Wolff \cite{wolff2016} phân biệt hai biến thể chính của mô hình Pub/Sub: Topic-based Pub/Sub, trong đó người đăng ký đăng ký vào các kênh cụ thể và nhận tất cả thông điệp được phát hành đến kênh đó; và Content-based Pub/Sub, trong đó người đăng ký định nghĩa các tiêu chí lọc và chỉ nhận thông điệp phù hợp với tiêu chí đã định.
Các công nghệ phổ biến để triển khai Pub/Sub bao gồm Apache Kafka, RabbitMQ, Google Cloud Pub/Sub, Amazon SNS và Redis Pub/Sub. Ví dụ, Apache Kafka tổ chức thông điệp thành các topic và lưu trữ chúng trong log phân tán, cho phép người đăng ký xử lý thông điệp theo tốc độ riêng của họ và thậm chí phát lại thông điệp cũ. RabbitMQ sử dụng mô hình exchange-queue, trong đó các exchange nhận thông điệp từ nhà xuất bản và định tuyến chúng đến các queue dựa trên các quy tắc khác nhau, và người đăng ký nhận thông điệp từ queue \cite{jun2018}.
Pub/Sub đặc biệt hữu ích cho các trường hợp như cập nhật trạng thái và sự kiện hệ thống, phân tích và giám sát, đồng bộ hóa dữ liệu giữa các dịch vụ, và IoT. Chẳng hạn, khi một đơn hàng được cập nhật, dịch vụ đơn hàng có thể phát hành sự kiện "order\_updated" đến một topic, và nhiều dịch vụ khác nhau như thanh toán, thông báo, và kho hàng có thể đăng ký topic này để cập nhật trạng thái tương ứng của chúng \cite{newman2015}.
Uber sử dụng mô hình Pub/Sub để xây dựng nền tảng sự kiện quy mô lớn, xử lý hàng trăm tỷ sự kiện mỗi ngày. Kiến trúc của họ sử dụng Apache Kafka làm nền tảng chính, cho phép các dịch vụ phát hành và đăng ký các sự kiện mà không cần biết về nhau. Khi một chuyến đi được tạo, sự kiện "trip\_created" được phát hành và nhiều dịch vụ đăng ký sự kiện này để thực hiện các chức năng khác nhau như thông báo cho tài xế, tính toán giá thành, và thu thập dữ liệu phân tích \cite{beyer2018}.
\subsection{Event Sourcing Pattern}
Event Sourcing là một mẫu kiến trúc trong đó thay vì lưu trữ trạng thái hiện tại của đối tượng, hệ thống lưu trữ chuỗi các sự kiện mô tả những thay đổi đã xảy ra với đối tượng đó theo thời gian. Trạng thái hiện tại được tạo ra bằng cách phát lại các sự kiện này \cite{fowler2002}.
Khi kết hợp với kiến trúc microservice, Event Sourcing thường được triển khai như một mô hình giao tiếp không đồng bộ one-to-many, trong đó các sự kiện được lưu trữ trong Event Store và nhiều dịch vụ có thể đăng ký để nhận thông báo về các sự kiện mới. Richardson \cite{richardson2019} chỉ ra rằng Event Sourcing thường được sử dụng kết hợp với Command Query Responsibility Segregation (CQRS) để tách biệt hoạt động đọc và ghi dữ liệu.
Event Sourcing có nhiều ưu điểm trong kiến trúc microservice, bao gồm khả năng lưu trữ lịch sử hoàn chỉnh của tất cả thay đổi (hữu ích cho kiểm toán và phân tích), khả năng phục hồi trạng thái hệ thống tại bất kỳ thời điểm nào, và khả năng phát triển song song các dịch vụ dựa trên luồng sự kiện chung.
Tuy nhiên, mẫu này cũng có những thách thức như độ phức tạp cao trong triển khai, vấn đề về schema evolution khi cấu trúc sự kiện thay đổi, và chi phí lưu trữ lớn do phải lưu trữ tất cả sự kiện. Event Sourcing phù hợp cho các hệ thống tài chính, quản lý đơn hàng, hệ thống quản lý nội dung, và các ứng dụng yêu cầu khả năng kiểm toán cao \cite{richardson2019}.
PayPal đã áp dụng mô hình Event Sourcing kết hợp với kiến trúc microservice để xây dựng nền tảng thanh toán mới. Mỗi giao dịch thanh toán được mô hình hóa như một chuỗi các sự kiện (payment\_initiated, payment\_authorized, payment\_captured, v.v.), và nhiều dịch vụ khác nhau đăng ký để nhận thông báo về các sự kiện mới để thực hiện các chức năng như phát hiện gian lận, thông báo cho người dùng, và cập nhật báo cáo tài chính \cite{raman2016}.
\subsection{Message Broker với Exchange Routing}
Message Broker với Exchange Routing là một mô hình giao tiếp không đồng bộ one-to-many, trong đó một thành phần trung gian (exchange) chịu trách nhiệm định tuyến thông điệp từ nhà xuất bản đến người đăng ký dựa trên các quy tắc định tuyến cụ thể \cite{hohpe2004}.
Theo Jun et al. \cite{jun2018}, kiến trúc của mô hình này bao gồm: Publisher (dịch vụ gửi thông điệp đến exchange), Exchange (thành phần định tuyến thông điệp dựa trên các quy tắc khác nhau), Bindings (quy tắc kết nối exchange với các hàng đợi), Queues (nơi lưu trữ thông điệp cho đến khi được xử lý), và Consumers (dịch vụ nhận và xử lý thông điệp từ hàng đợi).
RabbitMQ, một trong những message broker phổ biến, hỗ trợ bốn loại exchange chính: Direct Exchange (định tuyến thông điệp dựa trên khóa định tuyến chính xác), Topic Exchange (định tuyến thông điệp dựa trên mẫu khóa định tuyến), Fanout Exchange (định tuyến thông điệp đến tất cả các hàng đợi được liên kết), và Headers Exchange (định tuyến thông điệp dựa trên các thuộc tính header).
Message Broker với Exchange Routing cung cấp nhiều ưu điểm như định tuyến linh hoạt, khả năng lọc thông điệp dựa trên nội dung hoặc metadata, cân bằng tải giữa nhiều instance của cùng một dịch vụ, và hỗ trợ các cấp độ Quality of Service khác nhau. Tuy nhiên, mô hình này cũng có những thách thức như khả năng trở thành điểm lỗi đơn, độ phức tạp cao trong vận hành, và khó khăn trong việc gỡ lỗi luồng thông điệp.
LinkedIn sử dụng kết hợp Apache Kafka và một hệ thống message broker tùy chỉnh để xây dựng Data Pipeline - một nền tảng xử lý dữ liệu thời gian thực xử lý hàng trăm tỷ sự kiện mỗi ngày. Họ sử dụng các mẫu exchange khác nhau để định tuyến dữ liệu: Fanout exchange để phân phối tất cả sự kiện đến các hệ thống phân tích, Topic exchange để định tuyến sự kiện cụ thể đến các dịch vụ chuyên biệt, và Direct exchange để cân bằng tải giữa nhiều instance của cùng một dịch vụ \cite{goodhope2012}.
\subsection{Streaming Platform}
Streaming Platform là một mô hình giao tiếp không đồng bộ one-to-many, tập trung vào việc xử lý luồng dữ liệu liên tục và quy mô lớn. Khác với các mô hình truyền thống, nền tảng streaming không chỉ chuyển thông điệp mà còn cung cấp khả năng xử lý và phân tích luồng dữ liệu thời gian thực \cite{richardson2019}.
Theo Aksakalli et al. \cite{aksakalli2021}, một nền tảng streaming điển hình bao gồm các thành phần sau: Stream Producers (dịch vụ tạo ra dữ liệu và đẩy vào luồng), Stream Storage (lưu trữ luồng dữ liệu, thường với khả năng lưu trữ lâu dài), Stream Processors (xử lý và biến đổi dữ liệu trong luồng), và Stream Consumers (dịch vụ đọc và phản ứng với dữ liệu từ luồng).
Apache Kafka là một trong những nền tảng streaming phổ biến nhất, cung cấp khả năng lưu trữ và xử lý luồng dữ liệu với tốc độ, quy mô và độ tin cậy cao. Các nền tảng khác bao gồm Apache Flink, Apache Spark Streaming, và Amazon Kinesis.
Streaming Platform đặc biệt hữu ích cho các trường hợp như xử lý dữ liệu lớn thời gian thực, đường ống dữ liệu (data pipeline), phát hiện bất thường và gian lận, và theo dõi và phân tích hành vi người dùng.
Netflix sử dụng Apache Kafka làm nền tảng cho Keystone - hệ thống xử lý luồng dữ liệu thời gian thực xử lý hơn 700 tỷ sự kiện mỗi ngày (hơn 8 triệu sự kiện mỗi giây) từ người dùng và dịch vụ nội bộ trên toàn cầu. Dữ liệu từ Keystone được tiêu thụ bởi hàng trăm dịch vụ khác nhau, bao gồm hệ thống đề xuất nội dung cá nhân hóa, giám sát chất lượng dịch vụ theo thời gian thực, và phân tích hành vi người dùng \cite{idc2021}.
\subsection{Ưu điểm và Hạn chế của Asynchronous Communication (one-to-many)}
Giao tiếp bất đồng bộ one-to-many mang lại nhiều ưu điểm đáng kể so với các mô hình giao tiếp khác trong kiến trúc microservice, nhưng cũng đi kèm với một số hạn chế cần được xem xét kỹ lưỡng.
Về ưu điểm, đầu tiên phải kể đến sự tách rời cao (high decoupling) giữa nhà xuất bản và người đăng ký. Nhà xuất bản không cần biết danh tính hoặc số lượng người đăng ký, cho phép thêm hoặc xóa người đăng ký mà không ảnh hưởng đến nhà xuất bản. Điều này tạo ra hệ thống linh hoạt, có thể mở rộng dễ dàng \cite{newman2015}. Thứ hai, mô hình này hỗ trợ khả năng mở rộng động (dynamic scalability). Có thể thêm người đăng ký mới bất kỳ lúc nào để xử lý tải tăng lên hoặc cung cấp chức năng mới mà không cần thay đổi nhà xuất bản. Ưu điểm thứ ba là khả năng xử lý đồng thời (parallel processing). Nhiều người đăng ký có thể xử lý cùng một thông điệp song song, tăng hiệu suất tổng thể của hệ thống \cite{wolff2016}. Giao tiếp one-to-many cũng mang lại khả năng chịu lỗi cao (fault tolerance). Lỗi trong một người đăng ký không ảnh hưởng đến nhà xuất bản hoặc các người đăng ký khác, tăng tính ổn định của hệ thống \cite{richardson2019}. Cuối cùng, mô hình này rất phù hợp cho xử lý sự kiện phân tán (distributed event processing). Cho phép xây dựng hệ thống phản ứng với các sự kiện một cách linh hoạt và mở rộng \cite{hohpe2004}.
Tuy nhiên, giao tiếp bất đồng bộ one-to-many cũng có những hạn chế đáng kể. Đầu tiên là đồ phức tạp cao hơn. Triển khai mô hình này thường đòi hỏi cơ sở hạ tầng bổ sung (như message broker hoặc hệ thống streaming) và logic phức tạp hơn để quản lý việc phát hành và đăng ký \cite{newman2015}. Thứ hai, debugging và tracing khó khăn hơn. Theo dõi luồng thông điệp qua nhiều dịch vụ và trong môi trường phân tán có thể rất phức tạp, đặc biệt khi xử lý các lỗi \cite{wolff2016}. Giao tiếp one-to-many cũng dẫn đến tính nhất quán yếu hơn (eventual consistency). Các dịch vụ khác nhau có thể xử lý thông điệp với tốc độ khác nhau, dẫn đến trạng thái hệ thống không đồng nhất trong một khoảng thời gian \cite{richardson2019}. Ngoài ra, mô hình này có thể gặp vấn đề về quản lý thứ tự thông điệp. Đảm bảo thông điệp được xử lý theo đúng thứ tự có thể khó khăn, đặc biệt trong môi trường phân tán \cite{aksakalli2021}. Cuối cùng, giao tiếp one-to-many có thể dẫn đến độ trễ end-to-end cao hơn. Mặc dù nhà xuất bản có thể phản hồi nhanh, thời gian để tất cả người đăng ký hoàn thành xử lý có thể đáng kể \cite{jun2018}.
Để giảm thiểu những hạn chế này, nhiều kỹ thuật và mẫu thiết kế đã được phát triển. Chẳng hạn, để cải thiện khả năng debugging và tracing, các công cụ như Zipkin và Jaeger có thể được sử dụng để theo dõi thông điệp qua hệ thống phân tán. Để quản lý thứ tự thông điệp, các nền tảng như Kafka hỗ trợ partitioning và ordering guarantees. Và để giải quyết vấn đề tính nhất quán yếu, các kỹ thuật như snapshot, event versioning, và materialized views có thể được áp dụng.
\subsection{Use cases phù hợp cho Asynchronous Communication (one-to-many)}
Giao tiếp bất đồng bộ one-to-many đặc biệt phù hợp cho một số trường hợp sử dụng cụ thể trong kiến trúc microservice. Hiểu rõ những trường hợp này giúp kiến trúc sư và nhà phát triển đưa ra quyết định đúng đắn về việc khi nào nên sử dụng mô hình giao tiếp này.
Trường hợp sử dụng đầu tiên và phổ biến nhất là thông báo sự kiện hệ thống (system event notification). Khi một sự kiện quan trọng xảy ra (như tạo đơn hàng, cập nhật hồ sơ người dùng, hoặc thay đổi trạng thái), nhiều dịch vụ khác nhau có thể cần biết về sự kiện đó. Ví dụ, khi một đơn hàng được tạo, dịch vụ thanh toán, dịch vụ thông báo, dịch vụ kho hàng, và dịch vụ phân tích đều cần được thông báo \cite{newman2015}.
Trường hợp thứ hai là tích hợp dữ liệu cross-service. Khi dữ liệu được tạo hoặc cập nhật trong một dịch vụ, các dịch vụ khác có thể cần sao chép hoặc chuyển đổi dữ liệu đó cho mục đích riêng của chúng. Ví dụ, khi dịch vụ người dùng cập nhật thông tin người dùng, dịch vụ tìm kiếm và dịch vụ đề xuất cần cập nhật chỉ mục của chúng \cite{richardson2019}.
Trường hợp thứ ba là xử lý dữ liệu thời gian thực (real-time data processing). Đối với các hệ thống cần phân tích hoặc phản ứng với dữ liệu thời gian thực, mô hình one-to-many cho phép nhiều dịch vụ xử lý song song cùng một luồng dữ liệu. Ví dụ, dữ liệu click stream của người dùng có thể được phân tích bởi nhiều dịch vụ để phát hiện hành vi bất thường, cập nhật mô hình ML, và cung cấp phân tích theo thời gian thực \cite{goodhope2012}.
Trường hợp thứ tư là logging và monitoring phân tán. Các hệ thống phân tán cần thu thập log và metric từ nhiều dịch vụ cho mục đích giám sát và phân tích. Mô hình one-to-many cho phép các dịch vụ phát hành log và metric đến một kênh trung tâm, nơi chúng có thể được tiêu thụ bởi nhiều dịch vụ như lưu trữ log, cảnh báo, và phân tích \cite{aksakalli2021}.
Trường hợp thứ năm là cung cấp feed dữ liệu cho các hệ thống bên ngoài. Khi nhiều hệ thống bên ngoài (như ứng dụng đối tác, dịch vụ phân tích, hoặc hệ thống báo cáo) cần truy cập vào cùng một luồng dữ liệu, mô hình one-to-many cho phép phân phối dữ liệu một cách hiệu quả mà không tạo thêm gánh nặng cho hệ thống nguồn \cite{beyer2018}.
Ngoài ra, các use case liên quan đến Internet of Things (IoT) cũng rất phù hợp với giao tiếp one-to-many. Đối với các hệ thống IoT, nơi dữ liệu từ nhiều thiết bị cần được thu thập và xử lý bởi nhiều dịch vụ, mô hình one-to-many cung cấp cách hiệu quả để phân phối dữ liệu đến tất cả các dịch vụ quan tâm \cite{indrasiri2020}.
Cuối cùng, các hệ thống cần khả năng chịu lỗi cao và tách rời mạnh mẽ giữa các thành phần cũng rất phù hợp với mô hình one-to-many. Tiếp cận này cho phép các dịch vụ hoạt động độc lập với nhau, làm tăng tính ổn định và độ tin cậy của hệ thống tổng thể \cite{fowler2002}.
\subsection{Kết luận}
Giao tiếp bất đồng bộ one-to-many đóng vai trò quan trọng trong các kiến trúc microservice hiện đại, cung cấp khả năng phân phối thông điệp từ một nguồn đến nhiều đích một cách hiệu quả. Các mẫu như Publish/Subscribe, Event Sourcing, Message Broker với Exchange Routing, và Streaming Platform cung cấp các cách khác nhau để triển khai giao tiếp one-to-many, mỗi mẫu với những ưu điểm và trường hợp sử dụng phù hợp riêng.
Mô hình này mang lại nhiều lợi ích như sự tách rời cao, khả năng mở rộng động, xử lý đồng thời, và khả năng chịu lỗi tốt. Tuy nhiên, nó cũng đặt ra những thách thức về độ phức tạp, debugging, tính nhất quán dữ liệu, và quản lý thứ tự thông điệp. Với các công nghệ và mẫu thiết kế phù hợp, những thách thức này có thể được giải quyết, cho phép xây dựng các hệ thống microservice mạnh mẽ và có khả năng mở rộng.
Các trường hợp sử dụng điển hình cho giao tiếp one-to-many bao gồm thông báo sự kiện hệ thống, tích hợp dữ liệu cross-service, xử lý dữ liệu thời gian thực, logging và monitoring phân tán, và IoT. Nhiều công ty công nghệ hàng đầu như Uber, LinkedIn, PayPal, và Netflix đã triển khai thành công các mô hình giao tiếp one-to-many trong kiến trúc microservice của họ để xử lý khối lượng dữ liệu và sự kiện khổng lồ.
Trong thực tế, một hệ thống microservice hiệu quả thường kết hợp cả giao tiếp đồng bộ, bất đồng bộ one-to-one, và bất đồng bộ one-to-many, sử dụng mỗi loại cho những trường hợp sử dụng phù hợp. Hiểu rõ các mẫu giao tiếp khác nhau và khi nào nên sử dụng chúng là chìa khóa để thiết kế một kiến trúc microservice thành công và có khả năng mở rộng.
Với sự phát triển của các công nghệ như serverless computing, edge computing, và 5G, tương lai của giao tiếp bất đồng bộ one-to-many trong microservice còn nhiều hứa hẹn. Những tiến bộ này sẽ tiếp tục mở rộng khả năng và hiệu quả của giao tiếp one-to-many, cho phép xây dựng các hệ thống phân tán ngày càng phức tạp và có khả năng mở rộng.
Với sự phát triển của các công nghệ như serverless computing, edge computing, và 5G, tương lai của giao tiếp bất đồng bộ one-to-many trong microservice còn nhiều hứa hẹn. Những tiến bộ này sẽ tiếp tục mở rộng khả năng và hiệu quả của giao tiếp one-to-many, cho phép xây dựng các hệ thống phân tán ngày càng phức tạp và có khả năng mở rộng.